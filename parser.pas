unit parser;

{$INCLUDE defines.inc} {$LONGSTRINGS ON}

interface
   uses Stack, FuncInfo, TokExpr, Values;

Type
   TLineInfo = LongInt; //This will probably become a record when functions get implemented // LOL NOPE
   TIf = Array[0..2] of TLineInfo;
   TLoop = Array[0..2] of TLineInfo;
     
   TConstructType = (CT_IF, CT_WHILE, CT_REPEAT);
   TConstructInfo = record
      Typ : TConstructType;
      Idx : LongWord
   end;
     
   PConstructStack = ^TConstructStack;
   TConstructStack = specialize GenericStack<TConstructInfo>;

Var
   IfArr : Array of TIf;
   RepArr, WhiArr : Array of TLoop;
    
   Func : PFunTrie;
   Cons : PValTrie;
    
   Pr : Array of TProc;
   Proc, ExLn : LongWord;

Procedure Fatal(Const Ln:LongWord;Const Msg:AnsiString;Const ErrCode:LongInt = 255);
Function MakeExpr(Const ExLo,ExHi,Ln:LongInt; T:LongInt):PExpr;
Procedure ProcessLine(Const L:AnsiString;Const N:LongWord);
Procedure ParseFile(Var InputFile:System.Text);
Procedure ReadFile(Var InputFile:System.Text);


implementation
   uses  Math, SysUtils, 
         Convert, Values_Typecast,
         Globals, EmptyFunc, CoreFunc
         {$IFDEF CGI} , Encodings, Functions_stdio {$ENDIF}
         ;

Const
   PREFIX_VAL = '$';
   PREFIX_REF = '&';
   
   SKIP_BREAK = True;
   SKIP_CONTINUE = False;
   
   INCL_INCLUDE = False;
   INCL_REQUIRE = True;

Var
   cstruStack : PConstructStack;
   mulico:LongWord; {$IFDEF CGI} codemode:LongWord; {$ENDIF}

Procedure Fatal(Const Ln:LongWord;Const Msg:AnsiString;Const ErrCode:LongInt = 255);
   {$IFDEF CGI} Var DTstr:AnsiString; {$ENDIF}
   begin
   If (Ln <> 0) then Writeln(StdErr, YukName,'(',Ln,'): Fatal: ',Msg)
                else Writeln(StdErr, YukName,': Fatal: ',Msg);
   {$IFDEF CGI}
   Writeln(StdOut,'Content-Type: text/html; charset=UTF-8');
   Writeln(StdOut);
   Writeln(StdOut, '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">');
   Writeln(StdOut, '<html lang="en">');
   Writeln(StdOut, '<head>');
   Writeln(StdOut, '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">');
   Writeln(StdOut, '<title>Error</title>');
   Writeln(StdOut, '</head>');
   Writeln(StdOut, '<body style="background: white; color: black">');
   Writeln(StdOut, '<h3>awful-cgi: fatal error</h3><hr>');
   Writeln(StdOut, '<p><strong>File:</strong> ',EncodeHTML(YukPath),'</p>');
   If (Ln <> 0) then Writeln(StdOut, '<p><strong>Line:</strong> ',Ln,'</p>');
   Writeln(StdOut, '<p><i>',EncodeHTML(Msg),'</i></p>');
   DateTimeToString(DTstr, dtf_def, Now());
   Writeln(StdOut, '<p><small>Generated by ',FULLNAME,', r.',VREVISION,', on ',DTstr,'.</small></p>');
   Writeln(StdOut, '</body>');
   Writeln(StdOut, '</html>');
   Halt(0)
   {$ELSE}
   Halt(ErrCode)
   {$ENDIF}
   end;

Procedure Error(Const Ln:LongWord;Const Msg:AnsiString); Inline;
   begin Writeln(StdErr,YukName,'(',Ln,'): Error: ',Msg) end;

Procedure DupeFuncFatal(Const Ln:LongWord; Const Name:AnsiString);
   Var Fn : PFuncInfo;
   begin
   Fn := Func^.GetVal(Name);
   If (Fn^.Usr) then begin
      If (Pr[Fn^.uid].Fil = 0)
         then Fatal(Ln,'duplicate function name "'+Name+'", originally declared in '+ScriptName+' on line '+IntToStr(Pr[Fn^.uid].Lin)+'.') 
         else Fatal(Ln,'duplicate function name "'+Name+'", originally declared in '+FileIncludes[Pr[Fn^.uid].Fil].Name+' on line '+IntToStr(Pr[Fn^.uid].Lin)+'.')
      end else Fatal(Ln,'function name "'+Name+'" collides with built-in function.')
   end;

Procedure cstruFatal(Const Ln:LongWord);
   Var cstru:TConstructInfo; Cnt:LongWord; PastWhat:ShortString;
   begin
   If (Ln <> 0) then PastWhat := 'function.'
                else PastWhat := 'end of code.';
   Cnt := cstruStack^.Count;
   While (Not cstruStack^.Empty) do begin
      cstru := cstruStack^.Pop();
      Case cstru.Typ of
             CT_IF: Writeln(StdErr,YukName,'(', IfArr[cstru.Idx][0],'): Error: !if block stretches past ',PastWhat);
          CT_WHILE: Writeln(StdErr,YukName,'(',WhiArr[cstru.Idx][0],'): Error: !while block stretches past ',PastWhat);
         CT_REPEAT: Writeln(StdErr,YukName,'(',RepArr[cstru.Idx][0],'): Error: !repeat block stretches past ',PastWhat)
      end end;
   Fatal(Ln, IntToStr(Cnt)+' unterminated code blocks.')
   end;

Function mkcstru(Const T:TConstructType; Const I:LongWord):TConstructInfo;
   begin Result.Typ := T; Result.Idx := I end;

Procedure AddExpr(Const Ex:PExpr);
   begin
   If (Pr[Proc].Num = Length(Pr[Proc].Exp)) 
      then SetLength(Pr[Proc].Exp, Length(Pr[Proc].Exp)+32);
   
   Pr[Proc].Exp[Pr[Proc].Num] := Ex;
   Pr[Proc].Num += 1
   end;

Var Tk:Array of AnsiString;
    HiTk, LeTk : LongInt;

Function MakeExpr(Const ExLo,ExHi,Ln:LongInt; T:LongInt):PExpr;
   Var ExLe : LongInt;
   
   Function ConstPrefix(C:Char):Boolean; Inline;
      begin Exit(Pos(C,'suflihob=')<>0) end;
   
   Function MakeToken(Var Index:LongInt):PToken;
      Var Tok,otk:PToken; atk:PArrTk; TkIn, Nest:LongInt;
          sex:PExpr; V:PValue; PS:PStr; CName:TStr; 
      begin
      // Check string prefix and generate token
      If (Tk[Index][1]=PREFIX_VAL) then begin
         New(Tok); New(PS); Tok^.Typ:=TK_VARI; Tok^.Ptr:=PS; 
         PS^:=Copy(Tk[Index],2,Length(Tk[Index]))
         end else
      If (Tk[Index][1]=PREFIX_REF) then begin
         New(Tok); New(PS); Tok^.Typ:=TK_REFE; Tok^.Ptr:=PS; 
         PS^:=Copy(Tk[Index],2,Length(Tk[Index]))
         end else
      If (Tk[Index][1]='=') then begin 
         CName:=Copy(Tk[Index],2,Length(Tk[Index]));
         V:=Cons^.GetVal(CName);
         If (V = NIL) then Fatal(Ln,'Unknown constant "'+CName+'".');
         New(Tok); Tok^.Typ:=TK_CONS; Tok^.Ptr:=V
         end else
      If (Tk[Index][1]='s') then begin
         V:=NewVal(VT_STR,Copy(Tk[Index],3,Length(Tk[Index])-3));
         New(Tok); Tok^.Typ:=TK_LITE; Tok^.Ptr:=V; V^.Lev := 0
         end else
      If (Tk[Index][1]='u') then begin
         V:=NewVal(VT_UTF,Copy(Tk[Index],3,Length(Tk[Index])-3));
         New(Tok); Tok^.Typ:=TK_LITE; Tok^.Ptr:=V; V^.Lev := 0
         end else
      If (Tk[Index][1]='i') then begin
         V:=NewVal(VT_INT,Convert.StrToInt(Copy(Tk[Index],2,Length(Tk[Index]))));
         New(Tok); Tok^.Typ:=TK_LITE; Tok^.Ptr:=V; V^.Lev := 0
         end else
      If (Tk[Index][1]='h') then begin
         V:=NewVal(VT_HEX,Convert.StrToHex(Copy(Tk[Index],2,Length(Tk[Index]))));
         New(Tok); Tok^.Typ:=TK_LITE; Tok^.Ptr:=V; V^.Lev := 0
         end else
      If (Tk[Index][1]='o') then begin
         V:=NewVal(VT_OCT,Convert.StrToOct(Copy(Tk[Index],2,Length(Tk[Index]))));
         New(Tok); Tok^.Typ:=TK_LITE; Tok^.Ptr:=V; V^.Lev := 0
         end else
      If (Tk[Index][1]='b') then begin
         V:=NewVal(VT_BIN,Convert.StrToBin(Copy(Tk[Index],2,Length(Tk[Index]))));
         New(Tok); Tok^.Typ:=TK_LITE; Tok^.Ptr:=V; V^.Lev := 0
         end else
      If (Tk[Index][1]='l') then begin
         V:=NewVal(VT_BOO,SysUtils.StrToBoolDef(Copy(Tk[Index],2,Length(Tk[Index])),False));
         New(Tok); Tok^.Typ:=TK_LITE; Tok^.Ptr:=V; V^.Lev := 0
         end else
      If (Tk[Index][1]='f') then begin
         V:=NewVal(VT_FLO,Convert.StrToReal(Copy(Tk[Index],2,Length(Tk[Index]))));
         New(Tok); Tok^.Typ:=TK_LITE; Tok^.Ptr:=V; V^.Lev := 0
         end else
         Tok:=NIL;
      // Check if next token is an array index
      If (Index < ExHi) and (Tk[Index+1][1] = '[') then begin
         If (Tok = NIL) then
            Fatal(Ln,'Index token ("[") found, but previous token is neither a variable name nor an expression.');
         otk:=Tok; Index += 1; TkIn := Index + 1; // E^.Tok[High(E^.Tok)];
         If (otk^.Typ = TK_VARI) or (otk^.Typ = TK_REFE) then begin
            Tok:=MakeToken(TkIn);
            If (Tok=NIL) then begin
               sex:=MakeExpr(ExLo,ExHi,Ln,Index+1);//MakeExpr(Tk, Ln, Index + 1);
               New(Tok); Tok^.Typ:=TK_EXPR; Tok^.Ptr:=sex
               end;
            CName:=PStr(otk^.Ptr)^; Dispose(PStr(otk^.Ptr)); New(atk);
            New(PS); atk^.Ptr:=PS; PS^:=CName;
            If (otk^.Typ = TK_REFE) then otk^.Typ := TK_AREF
                                    else otk^.Typ := TK_AVAL;
            SetLength(atk^.Ind, 1); atk^.Ind[0] := Tok;
            otk^.Ptr := atk
            end else 
            Fatal(Ln,'Index token ("[") found, but previous token is neither a variable name nor an expression.');
         Nest:=0;
         While (Index <= ExHi) do 
            //If (Length(Tk[Index])=0) then Index +=1 else
            If (Tk[Index][1]='[') then begin Nest+=1; Index+=1 end else
            If (Tk[Index][1]=']') then begin
               Nest-=1; If (Nest=0) then Break else Index+=1
               end else Index+=1;
         If (Nest>0) then Error(Ln,'Un-closed index expression. ("[" without a matching "]".)');
         Tok := otk // Return value
         end;
      Exit(Tok)
      end;
   
   Function NewToken(Const Typ:TValueType;Const Val:Int64):PToken;
      Var Tok:PToken; 
      begin
      New(Tok); Tok^.Typ := TK_LITE; Tok^.Ptr := NewVal(Typ,Val); 
      PValue(Tok^.Ptr)^.Lev := 0;
      Exit(Tok)
      end;
   
   Var E:PExpr; FPtr:PFuncInfo; sex:PExpr; A,Etk:LongInt;
       Tok,otk:PToken; V:PValue; {PS:PStr;} atk : PArrTk;
       Nest:LongInt; CName:TStr; Tmp:LongInt; cstru : TConstructInfo;
   
   Procedure AddToken(Const Tok:PToken);
      begin
      If (Etk = Length(E^.Tok))
         then SetLength(E^.Tok, Etk + 8);
      
      E^.Tok[Etk] := Tok;
      Etk += 1
      end;
   
   Function cstruType():ShortString;
      begin
      Case cstru.Typ of
             CT_IF: Exit('!if');
          CT_WHILE: Exit('!while');
         CT_REPEAT: Exit('!repeat');
         else Exit('!_UNKNOWN')
      end end;
   
   Procedure Construct_If();
      begin
      A := Length(IfArr);
      SetLength(IfArr,(A+1));
      IfArr[A][0]:=Ln; // !if line number
      IfArr[A][1]:=-1; // !else expression number
      IfArr[A][2]:=-1; // !fi expression number
      cstruStack^.Push(mkcstru(CT_IF, A)); // push !if identifier on stack, so we know which !if to match !else and !fi to
      
      SetLength(E^.Tok, 1);
      E^.Tok[0] := NewToken(VT_INT, A);
      FPtr := @FuncInfo_If
      end;
   
   Procedure Construct_Else();
      begin
      If (cstruStack^.Empty) then Fatal(Ln,'!else without corresponding !if.');
      cstru:=cstruStack^.Peek();
      
      If (cstru.Typ <> CT_IF)
         then Fatal(Ln,'!else inside a '+cstruType()+' block.');
      If (IfArr[cstru.Idx][1]>=0)
         then Fatal(Ln,'!if from line '+IntToStr(IfArr[cstru.Idx][0])+' has a second !else.');
      
      If (ExLe - T > 1) then Fatal(Ln,'!else cannot take any arguments.');
      
      IfArr[cstru.Idx][1]:=Pr[Proc].Num; // set !else expression number
      
      SetLength(E^.Tok, 1);
      E^.Tok[0] := NewToken(VT_INT, cstru.Idx);
      FPtr := @FuncInfo_Else
      end;
   
   Procedure Construct_Fi();
      begin
      If (cstruStack^.Empty) then Fatal(Ln,'!fi without corresponding !if.');
      cstru:=cstruStack^.Pop();
      
      If (cstru.Typ <> CT_IF)
         then Fatal(Ln,'!fi inside a '+cstruType()+' block.');
      
      If (ExLe - T > 1) then Fatal(Ln,'!fi cannot take any arguments.');
      
      IfArr[cstru.Idx][2]:=Pr[Proc].Num; // set !fi expr num
      If (IfArr[cstru.Idx][1]<0) then IfArr[cstru.Idx][1]:=Pr[Proc].Num; // if !else expr num is not present, set it to !fi expr num
      
      SetLength(E^.Tok, 1);
      E^.Tok[0] := NewToken(VT_INT, cstru.Idx);
      FPtr := @FuncInfo_NIL
      end;
   
   Procedure Construct_While();
      begin
      A:=Length(WhiArr);
      SetLength(WhiArr,(A+1));
      WhiArr[A][0]:=Ln;             // set !while line number
      WhiArr[A][1]:=Pr[Proc].Num-1; // set !while jump point
      WhiArr[A][2]:=-1;             // set !done expr num
      cstruStack^.Push(mkcstru(CT_WHILE, A));
      
      SetLength(E^.Tok, 1);
      E^.Tok[0] := NewToken(VT_INT, A);
      FPtr := @FuncInfo_While
      end;
   
   Procedure Construct_Done();
      begin
      If (cstruStack^.Empty()) then Fatal(Ln,'!done without corresponding !while.');
      cstru:=cstruStack^.Pop();
      
      If (cstru.Typ <> CT_WHILE)
         then Fatal(Ln,'!done inside a '+cstruType()+' block.');
      
      If (ExLe - T > 1) then Fatal(Ln,'!done cannot take any arguments.');
      
      WhiArr[cstru.Idx][2]:=Pr[Proc].Num; // set !done expr num
      
      SetLength(E^.Tok, 1);
      E^.Tok[0] := NewToken(VT_INT, cstru.Idx);
      FPtr := @FuncInfo_Done
      end;
   
   Procedure Construct_Repeat();
      begin
      If (ExLe - T > 1) then Fatal(Ln,'!repeat cannot take any arguments.');
      
      A:=Length(RepArr);
      SetLength(RepArr,(A+1));
      RepArr[A][0]:=Ln;           // set !repeat line number
      RepArr[A][1]:=Pr[Proc].Num; // set !repeat jump point
      RepArr[A][2]:=-1;           // set !until expr num
      cstruStack^.Push(mkcstru(CT_REPEAT, A));
      
      SetLength(E^.Tok, 1);
      E^.Tok[0] := NewToken(VT_INT, A);
      FPtr := @FuncInfo_NIL
      end;
   
   Procedure Construct_Until();
      begin
      If (cstruStack^.Empty()) then Fatal(Ln,'!until without corresponding !repeat.');
      cstru:=cstruStack^.Pop();
      
      If (cstru.Typ <> CT_REPEAT)
         then Fatal(Ln,'!until inside a '+cstruType()+' block.');
      
      RepArr[cstru.Idx][2]:=Pr[Proc].Num; // set !until expr num
      
      SetLength(E^.Tok, 1);
      E^.Tok[0] := NewToken(VT_INT, cstru.Idx);
      FPtr := @FuncInfo_Until
      end;
   
   Procedure Construct_Const();
      begin
      If (ExLe <> 3) then Fatal(Ln,'Wrong number of arguments passed to !const ('+IntToStr(ExLe)+').');
      If (Length(Tk[T+1])=0) or (Tk[T+1][1]<>'=')
         then Fatal(Ln,'!const names must start with a "=" character.');
      CName:=Copy(Tk[T+1],2,Length(Tk[T+1]));
      If (Cons^.IsVal(CName)) 
         then Fatal(Ln,'Redefinition of const "'+CName+'".');
      If (Length(Tk[T+2])=0) or (Not ConstPrefix(Tk[T+2][1]))
         then Fatal(Ln,'Second argument for !const must be either a value literal or another const.');
      If (Tk[T+2][1]='s') then
         V:=NewVal(VT_STR,Copy(Tk[T+2],3,Length(Tk[T+2])-3)) else
      If (Tk[T+2][1]='u') then
         V:=NewVal(VT_UTF,Copy(Tk[T+2],3,Length(Tk[T+2])-3)) else
      If (Tk[T+2][1]='f') then
         V:=NewVal(VT_FLO,StrToReal(Copy(Tk[T+2],2,Length(Tk[T+2])))) else
      If (Tk[T+2][1]='l') then
         V:=NewVal(VT_BOO,StrToBoolDef(Copy(Tk[T+2],2,Length(Tk[T+2])),False)) else
      If (Tk[T+2][1]='i') then
         V:=NewVal(VT_INT,Convert.StrToInt(Copy(Tk[T+2],2,Length(Tk[T+2])))) else
      If (Tk[T+2][1]='h') then
         V:=NewVal(VT_HEX,Convert.StrToHex(Copy(Tk[T+2],2,Length(Tk[T+2])))) else
      If (Tk[T+2][1]='o') then
         V:=NewVal(VT_OCT,Convert.StrToOct(Copy(Tk[T+2],2,Length(Tk[T+2])))) else
      If (Tk[T+2][1]='b') then
         V:=NewVal(VT_BIN,Convert.StrToBin(Copy(Tk[T+2],2,Length(Tk[T+2])))) else
      If (Tk[T+2][1]='=') then begin
         V:=Cons^.GetVal(Copy(Tk[T+2],2,Length(Tk[T+2])));
         If (V = NIL) then Fatal(Ln,'Unknown const "'+Copy(Tk[T+2],2,Length(Tk[T+2]))+'".');
         V := CopyVal(V)
         end;
      V^.Lev := 0; Cons^.SetVal(CName,V)
      end;
   
   Procedure Construct_Fun();
      begin
      If (Not cstruStack^.Empty) then begin
         cstru:=cstruStack^.Peek();
         Fatal(Ln,'!fun inside a '+cstruType()+'block.')
         end;
      If (Proc<>0) then Fatal(Ln,'Nested function declaration.');
      If ((ExLe-T)<2) then Fatal(Ln,'No function name specified.');
      If (Length(Tk[T+1])=0) or (Tk[T+1][1]<>':')
         then Fatal(Ln,'Function names must start with the colon (":") character.');
      CName:=Copy(Tk[T+1],2,Length(Tk[T+1]));
      If (Func^.IsVal(CName))
         then DupeFuncFatal(Ln,CName);
      SetLength(Pr,Length(Pr)+1);
      Proc:=High(Pr); ExLn:=0;
      Pr[Proc].Fil := Length(FileIncludes); Pr[Proc].Lin := Ln;
      Pr[Proc].Num := 0; SetLength(Pr[Proc].Exp,0);
      SetLength(Pr[Proc].Arg, ExLe - 2); A := 0;
      Func^.SetVal(CName,MkFunc(Proc)); T+=2;
      While (T < ExLe) do begin
         If (Length(Tk[T])=0) then begin
            Error(Ln,'Empty token (#'+IntToStr(T)+').'); T+=1; Continue
            end;
         If ((Tk[T][1]<>'$') and (Tk[T][1]<>'&'))  then
            Fatal(Ln,'Function arguments must specify variable names. ("$name" or "&name").');
         //SetLength(Pr[Proc].Arg,Length(Pr[Proc].Arg)+1);
         Pr[Proc].Arg[A]:=Copy(Tk[T],2,Length(Tk[T]));
         A+=1; T+=1 end;
      SetLength(Pr[Proc].Arg, A);
      end;
   
   Procedure Construct_Nuf();
      begin
      If (Proc = 0) then Fatal(Ln,'!nuf without corresponding !fun.');
      If (Not cstruStack^.Empty) then cstruFatal(Ln);
      
      SetLength(Pr[Proc].Exp, Pr[Proc].Num);
      Proc:=0; ExLn:=Pr[0].Num-1
      end;
   
   Procedure Construct_Skip(Const Brk:Boolean);
      Var cstruName : ShortString; Constant : PValue; 
          DepStr:AnsiString; Dep:Int64; Met:LongWord;
      begin
      If (Brk) then cstruName := '!break' else cstruName := '!continue';
      If (cstruStack^.Empty) then Fatal(Ln,cstruName+' outside a loop block.');
      
      If (ExLe > 1) then begin
         If (ExLe > 2) then Fatal(Ln,cstruName+' accepts at most one parameter.');
         DepStr := Copy(Tk[1], 2, Length(Tk[T]));
         If (Tk[1][1]='s') then Dep := Convert.StrToInt(Copy(DepStr,2,Length(DepStr)-2)) else
         If (Tk[1][1]='u') then Dep := Convert.StrToInt(Copy(DepStr,2,Length(DepStr)-2)) else
         If (Tk[1][1]='i') then Dep := Convert.StrToInt(DepStr) else
         If (Tk[1][1]='h') then Dep := Convert.StrToHex(DepStr) else
         If (Tk[1][1]='o') then Dep := Convert.StrToOct(DepStr) else
         If (Tk[1][1]='b') then Dep := Convert.StrToBin(DepStr) else
         If (Tk[1][1]='f') then Dep := Trunc(Convert.StrToReal(DepStr)) else
         If (Tk[1][1]='l') then Dep := BoolToInt(StrToBoolDef(DepStr,False)) else
         If (Tk[1][1]='=') then begin
            Constant := Cons^.GetVal(DepStr);
            If (Constant = NIL) then Fatal(Ln,'Unknown constant "'+DepStr+'".');
            Dep := ValAsInt(Constant)
            end else
            Fatal(Ln,'Arguments for '+cstruName+' must be either value literals or constants.');
         
         If (Dep <= 0) then Fatal(Ln,'invalid '+cstruName+' depth ('+IntToStr(Dep)+').')
         end else Dep := 1;
      
      A := 0; Met := 0;
      Repeat
         cstru := cstruStack^.Peek(A); A += 1;
         If (cstru.Typ <> CT_IF) then begin 
            Met += 1; If (Met = Dep) then break
            end;
         If (cstruStack^.Count <= A) then begin
            If (Dep = 1) then Fatal(Ln,cstruName+' outside a loop block.')
                         else Fatal(Ln,cstruName+' depth ('+IntToStr(Dep)+') is greater than loop nest level ('+IntToStr(Met)+').')
            end
         until False;
      
      SetLength(E^.Tok, 2);
      E^.Tok[0] := NewToken(VT_INT, Ord(cstru.Typ));
      E^.Tok[1] := NewToken(VT_INT, cstru.Idx);
      If (Brk) then FPtr := @FuncInfo_Break
               else FPtr := @FuncInfo_Continue
      end;
   
   Procedure Construct_Include(Const Req:Boolean);
      Var FileName,Construct:AnsiString; Constant:PValue; F:System.Text;
          OldName, OldPath, OldDir : AnsiString; FiIn:LongWord;
          OldNameCons, OldPathCons : PValue;
      begin
      If (Req) then Construct := '!require' else Construct := '!include';
      FileName := Copy(Tk[T], 2, Length(Tk[T]));
      If (Tk[T][1]='s') then begin Delete(FileName,Length(FileName),1); Delete(FileName,1,1) end else
      If (Tk[T][1]='u') then begin Delete(FileName,Length(FileName),1); Delete(FileName,1,1) end else
      If (Tk[T][1]='i') then FileName:=IntToStr(Convert.StrToInt(FileName)) else
      If (Tk[T][1]='h') then FileName:=HexToStr(Convert.StrToHex(FileName)) else
      If (Tk[T][1]='o') then FileName:=OctToStr(Convert.StrToOct(FileName)) else
      If (Tk[T][1]='b') then FileName:=BinToStr(Convert.StrToBin(FileName)) else
      If (Tk[T][1]='f') then FileName:=FloatToStr(Convert.StrToReal(FileName)) else
      If (Tk[T][1]='l') then FileName:=BoolToStr(StrToBoolDef(FileName,False)) else
      If (Tk[T][1]='=') then begin
         Constant := Cons^.GetVal(FileName);
         If (Constant = NIL) then Fatal(Ln,'Unknown constant "'+FileName+'".');
         FileName := ValAsStr(Constant)
         end else
         Fatal(Ln,'Arguments for '+Construct+' must be either value literals or constants.');
      
      Assign(F, FileName); {$I-} Reset(F); {$I+}
      If (IOResult()<>0) then begin
         If (Req) then Fatal(Ln,'Unable to include file "'+FileName+'".')
                  else Error(Ln,'Unable to include file "'+FileName+'".');
         Exit() end;
      
      FiIn := Length(FileIncludes);
      SetLength(FileIncludes, FiIn + 1);
      FileIncludes[FiIn].Name := FileName;
      
      OldDir := GetCurrentDir();
      OldName := YukName;
      OldPath := YukPath;
      
      YukPath := ExpandFileName(FileName);
      YukName := ExtractFileName(YukPath);
      {$I-} ChDir(ExtractFilePath(YukPath)); {$I+}
      
      OldNameCons := Cons^.GetVal('FILE-NAME');
      Constant := NewVal(VT_STR, YukName); Constant^.Lev := 0; Cons^.SetVal('FILE-NAME', Constant);
      FileIncludes[FiIn].Cons[0] := Constant;
      
      OldPathCons := Cons^.GetVal('FILE-PATH');
      Constant := NewVal(VT_STR, YukPath); Constant^.Lev := 0; Cons^.SetVal('FILE-PATH', Constant);
      FileIncludes[FiIn].Cons[1] := Constant;
      
      ParseFile(F);
      Close(F);
      
      Cons^.SetVal('FILE-NAME', OldNameCons); YukName := OldName;
      Cons^.SetVal('FILE-PATH', OldPathCons); YukPath := OldPath;
      {$I-} ChDir(OldDir) {$I+}
      end;
   
   begin
   New(E); ExLe := ExHi - ExLo + 1;
   If (Tk[T][1]=':') then begin
      FPtr := Func^.GetVal(Tk[T][2..Length(Tk[T])]);
      If (FPtr = NIL)
         then Fatal(Ln,'Unknown function: "'+Tk[T]+'".');
      
      If (FPtr^.Usr) then begin
         SetLength(E^.Tok, 1);
         E^.Tok[0] := NewToken(VT_INT, FPtr^.uid);
         FPtr := @FuncInfo_AutoCall
         end
      end else
   If (Tk[T][1]='!') then Case (Tk[T]) of
      '!if': 
         Construct_If();
      '!else': 
         Construct_Else();
      '!fi': 
         Construct_Fi();
      '!while':
         Construct_While();
      '!done':
         Construct_Done();
      '!repeat':
         Construct_Repeat();
      '!until':
         Construct_Until();
      '!break':
         Construct_Skip(SKIP_BREAK);
      '!continue':
         Construct_Skip(SKIP_CONTINUE);
      '!const': begin
         Construct_Const();
         Dispose(E); Exit(NIL)
         end;
      '!fun': begin
         Construct_Fun();
         Dispose(E); Exit(NIL)
         end;
      '!nuf': begin
         Construct_Nuf();
         Dispose(E); Exit(NIL)
         end;
      '!include': begin
         T += 1; If (T > ExHi) then Error(Ln,'!include without arguments.');
         Repeat Construct_Include(INCL_INCLUDE); T += 1 until (T > ExHi);
         Dispose(E); Exit(NIL)
         end;
      '!require': begin
         T += 1; If (T > ExHi) then Fatal(Ln,'!require without arguments.');
         Repeat Construct_Include(INCL_REQUIRE); T += 1 until (T > ExHi);
         Dispose(E); Exit(NIL)
         end;
      {'!return': begin
         If (Proc = 0) then Fatal(Ln,'!return used in main function.');
         FPtr:=@F_Return
         end; }
      else
         Fatal(Ln,'Unknown language construct: "'+Tk[T]+'".')
      end else
      Fatal(Ln,'First token in expression ("'+Tk[T]+'") is neither a function call nor a language construct.');
   E^.Fun:=FPtr^.Ptr; E^.Ref := FPtr^.Ref;
   T+=1; If (T > ExHi) then begin
      E^.Num := Length(E^.Tok) - 1;
      SetLength(E^.Arg,E^.Num+1);
      Exit(E); end;
   Etk := Length(E^.Tok); If (ExLe > Etk) then SetLength(E^.Tok, ExLe);
   While (T <= ExHi) do begin
      If (Length(Tk[T])=0) then Error(Ln,'Empty token (#'+IntToStr(T)+').') else
      If (Tk[T][1]='(') then begin
         sex:=MakeExpr(ExLo,ExHi,Ln,T+1);//MakeExpr(Tk,Ln,T+1);
         New(Tok); Tok^.Typ:=TK_EXPR; Tok^.Ptr:=sex;
         AddToken(Tok);
         Nest:=0;
         While (T <= ExHi) do 
            If (Length(Tk[T])=0) then T+=1 else
            If (Tk[T][1]='(') then begin Nest+=1; T+=1 end else
            If (Tk[T][1]=')') then begin
               Nest-=1; If (Nest=0) then Break else T+=1
               end else T+=1;
         If (Nest>0) then Error(Ln,'Un-closed sub-expression. ("(" without a matching ")".)')
         end else
      If (Tk[T][1]=')') then begin
         SetLength(E^.Tok, Etk); SetLength(E^.Arg, Etk); 
         E^.Num := Etk-1; Exit(E)
         end else 
      If (Tk[T][1]='[') then begin
         If (Length(E^.Tok)=0) then
            Fatal(Ln,'Index token ("[") found, but previous token is neither a variable name nor an expression.');
         otk:=E^.Tok[Etk-1]; Tmp:=T+1;
         If (otk^.Typ = TK_AREF) or (otk^.Typ = TK_AVAL) or (otk^.Typ = TK_AFLY) then begin
            Tok:=MakeToken(Tmp);
            If (Tok=NIL) then begin
               sex:=MakeExpr(ExLo,ExHi,Ln,T+1);//MakeExpr(Tk,Ln,T+1);
               New(Tok); Tok^.Typ:=TK_EXPR; Tok^.Ptr:=sex
               end;
            atk := PArrTk(otk^.Ptr);
            SetLength(atk^.Ind, Length(atk^.Ind) + 1);
            atk^.Ind[High(atk^.Ind)] := Tok
            end else
         If (otk^.Typ = TK_EXPR) then begin
            Tok:=MakeToken(Tmp);
            If (Tok=NIL) then begin
               sex:=MakeExpr(ExLo,ExHi,Ln,T+1);//MakeExpr(Tk,Ln,T+1);
               New(Tok); Tok^.Typ:=TK_EXPR; Tok^.Ptr:=sex
               end;
            New(atk); atk^.Ptr := otk^.Ptr;
            SetLength(atk^.Ind, 1); atk^.Ind[0] := Tok;
            otk^.Ptr := atk; otk^.Typ := TK_AFLY
            end else
            Fatal(Ln,'Index token ("[") found, but previous token is neither a variable name nor an expression.');
         Nest:=0;
         While (T <= HiTk) do 
            If (Length(Tk[T])=0) then T+=1 else
            If (Tk[T][1]='[') then begin Nest+=1; T+=1 end else
            If (Tk[T][1]=']') then begin
               Nest-=1; If (Nest=0) then Break else T+=1
               end else T+=1;
         If (Nest>0) then Error(Ln,'Un-closed index expression. ("[" without a matching "]".)')
         end else 
      If (Tk[T][1]=']') then begin
         SetLength(E^.Tok, Etk); SetLength(E^.Arg, Etk); 
         E^.Num := Etk-1; Exit(E)
         end else
      If (Tk[T][1]=':') then begin
         sex:=MakeExpr(ExLo,ExHi,Ln,T);//MakeExpr(Tk,Ln,T);
         New(Tok); Tok^.Typ:=TK_EXPR; Tok^.Ptr:=sex;
         AddToken(Tok);
         SetLength(E^.Tok, Etk); SetLength(E^.Arg, Etk); 
         E^.Num := Etk-1; Exit(E)
         end else
      If (Tk[T][1]='!') then begin
         Fatal(Ln,'Language construct used as a sub-expression. ("'+Tk[T]+'").')
         end else begin
         Tok:=MakeToken(T);
         If (Tok<>NIL) then begin
            AddToken(Tok)
            end else
            Fatal(Ln,'Invalid token ("'+Tk[T]+'").')
         end;
      T+=1 end;
   SetLength(E^.Tok, Etk); SetLength(E^.Arg, Etk);
   E^.Num := Etk-1; Exit(E)
   end;

Procedure ProcessLine(Const L:AnsiString;Const N:LongWord);
   Type TStrSearch = (STR_NOPE, STR_MAYBE, STR_START, STR_INSIDE);
   
   Var P,S,Len:LongInt; Str : TStrSearch; Delim:Char;
       PipeChar:AnsiString; Ex:PExpr; Utf:Boolean;
   
   Function BreakToken(Const Ch:Char):Boolean; Inline;
      begin Exit((Ch <= ' ') or (Ch in ['(','|',')','~','[','#',']'])) end;
   
   Procedure EnsureEmptyPlaces(Len:LongInt); Inline;
      begin
         Len := HiTk + 1 + Len;
         If (Len > LeTk) then begin
            LeTk := Len + 4; SetLength(Tk,LeTk)
      end end;
   
   Procedure SetHighToken(Const Content:AnsiString); Inline;
      begin HiTk += 1; Tk[HiTk] := Content end;
   
   Procedure RemoveHighToken(); Inline;
      begin HiTk -= 1 end;
   
   begin
      S:=1; Len := Length(L); // Remember script line length and set Startpos to 0
      
      {$IFDEF CGI}
         If (Len = 0) then begin 
            // Empty line. If not in codemode, add expression outputting a blank line.
            If (Codemode = 0) then begin 
               New(Ex); Ex^.Ref := REF_CONST; Ex^.Num := -1;
               SetLength(Ex^.Tok,0); SetLength(Ex^.Arg,0);
               Ex^.Fun := @F_Writeln;
               AddExpr(Ex)
            end;
            Exit()
         end else
            // Non-empty line. If in codemode, skip whitespace on left side.
            If (Codemode > 0) then begin
               While (L[S]<=' ') and (S <= Len) do S += 1;
               If (S > Len) then Exit()
         end;
      {$ELSE}
      
         If (Len = 0) then Exit(); // Bail out if empty line
         While (L[S]<=#$20) and (S <= Len) do S += 1; // Skip whitespace on left side
         
         If (S > Len) then Exit(); // Line consists only of whitespace, nothing to do
         While (L[Len]<=#$20) and (Len > 0) do Len -= 1; // Skip whitespace on right side
      {$ENDIF}
      
      HiTk := -1;                  // HighToken = -1 (no tokens) 
      Str:=STR_MAYBE; Delim:=#255; // Stringmode = "possible to enocunter a string literal", delimiter = #255
      PipeChar:='';                // Pipe "|" matching char (either "(" or "[")
      P:=1;                        // Current position in text
      
      // Go through loop as long as S (token start) is inside linestring
      While (S <= Len) do begin
         
         // Inside multi-line comment
         If (mulico > 0) then begin
            If (P>Len) then S := Len+1 else
            If (L[P]='#') then
               If (Len>P) and (L[P+1]='~') then mulico+=1 else
               If (P>1) and (L[P-1]='~') then begin
                  If (mulico > 1)
                     then mulico-=1 
                     else begin
                        S:=P+1; {P-=1;} mulico:=0
                     end 
               end
         end else
         {$IFDEF CGI}
         
         // If not in codemode 
         If (codemode = 0) then begin
         
            // If current P position greater than string length, we are at end of line
            If (P > Len) then begin
               
               // If previous expression didn't end with ~terminator, add it.
               // Oterwise, just ensure we have enough place to put :writeln <line content>.
               If (HiTk >= 0) and (Tk[HiTk][1] <> '~') then begin
                  EnsureEmptyPlaces(3); SetHighToken('~')
               end else
                  EnsureEmptyPlaces(2);
               
               SetHighToken(':writeln');
               SetHighToken('s"' + L[S..Len] +'"');
               S := Len + 1; P-=1
            end else // else = we are not at end of line
            
            // Check if character is ? - we may have encountered a <?yuk tag
            If (L[P] = '?') then begin
               
               // Check if this really is a <?yuk tag
               If ((P>1) and (L[P-1] = '<')) and ((P <= Len-3) and (L[P+1..P+3] = 'yuk')) then begin
                  
                  // Check if tag is not on line start
                  If (P > S+1) then begin
                     
                     // If previous expression didn't end with ~terminator, add it.
                     // Oterwise, just ensure we have enough place to put :write <line content> ~.
                     If (HiTk >= 0) and (Tk[HiTk][1]<>'~') then begin
                        EnsureEmptyPlaces(4); SetHighToken('~')
                     end else
                        EnsureEmptyPlaces(3);
                     
                     SetHighToken(':write');
                     SetHighToken('s"' + L[S..P-2] +'"');
                     SetHighToken('~')
                  end else
                  // We are on line start. Just in case, check if there are any tokens and add ~terminator if needed.
                     If (HiTk >= 0) and (Tk[HiTk][1] <> '~') then begin
                        EnsureEmptyPlaces(1); SetHighToken('~')
                     end;
                  
                  // Mark we are inside codemode. Move S and P positions
                  codemode += 1; S:=P+5; P+=3
               end else
               // Not a <?yuk tag, but maybe a ?> tag?
               If (P < Len) and (L[P+1] = '>') and (codemode = 0) then 
                  Fatal(N, 'Unexpected codemode close tag ("?>").')
                  
            end else
            // Character is not '?'. Check if first line and character is '#' - if so, may be shebang.
            If (N = 1) and (P = 1) and (L[1]='#') then begin
               If (Len>1) and (L[2]='!') then S:=Len+1 // #!shebang
            end
         end else
         {$ENDIF}
         
         // Not inside a string literal
         If (Str < STR_START) then begin
            
            // If at end of line, or current char is a token breaker
            If (P > Len) or (BreakToken(L[P])) then begin
               
               // If current char is whitespace
               If (L[P] <= #$20) then begin
                  
                  // If P has moved from S, add S to P substring as new token
                  If (P > S) then begin
                     EnsureEmptyPlaces(1);
                     SetHighToken(Copy(L,S,P-S))
                  end;
                  
                  // Skip any additional whitespace bytes after this one
                  While (P < Len) and (L[P+1] <= #$20) do P+=1;
                  S := P+1; P+=1
               end else 
               
               // If current char is '#', we have encountered a comment
               If (L[P]='#') then begin
                  
                  // If P has moved from S, add S to P substring as new token
                  If (P > S) then begin
                     EnsureEmptyPlaces(1);
                     SetHighToken(Copy(L,S,P-S))
                  end;
                  
                  // Check if multi-line comment
                  If (Len > P) and (L[P+1]='~') 
                     then begin S := P+2; P+=2; mulico += 1 end // Yes, move S and P and mark multi-line-comment flag
                     else S:=Len+1                              // Nope, just mark line as read fully
               end
               
               {$IFDEF CGI}
               // Check if codemode close tag ('?>') encountered
               else If (P >= 3) and (L[P-2..P-1] = '?>') then begin
                  codemode -= 1; S:=P; P+=1 
               end
               {$ENDIF}
               
               // Character is token breaker, but not whitespace nor pound. This means it must be (|)[#].
               else begin
                  
                  // P has moved from S, add S to P substring as token
                  If (P > S) then begin
                     EnsureEmptyPlaces(1);
                     SetHighToken(Copy(L,S,P-S))
                  end;
                  
                  // P is inside string. Add L[P] as token and skip any following whitespace.
                  If (P <= Len) then begin
                     EnsureEmptyPlaces(1);
                     SetHighToken(L[P]);
                     While (P<Len) and (L[P+1] <= #$20) do P+=1
                  end;
                  
                  // Move S to new position (which should be after token breaker + skipped whitespace)
                  S := P + 1; P += 1;
                  
                  // Check if token is '|' pipechar
                  If (Tk[HiTk]='|') then begin
                     
                     // If PipeChar length is 0, means there is no ( or [ to match
                     If (Length(PipeChar)=0) then begin
                     
                        // Remove '|' token and emit error
                        RemoveHighToken();
                        Error(N, 'Pipe ("|") without matching parentheses or brackets.') 
                     
                     end else begin
                        
                        // Make sure we have place for new token
                        EnsureEmptyPlaces(1);
                        
                        // Morph '|' into appropriate closing paren/bracket and add opening paren/bracket
                        If (PipeChar[Length(PipeChar)] = '(') then begin
                           Tk[HiTk]:=')'; SetHighToken('(')
                        end else begin
                           Tk[HiTk]:=']'; SetHighToken('[')
                        end
                     end
                  end else // Token is not pipechar
                  
                  // Check if token is paren/bracket opening - if yes, add it to PipeChar stringstack
                  If (Tk[HiTk]='(') or (Tk[HiTk] = '[') then
                     PipeChar += Tk[HiTk]
                  else
                  
                  // Check if token is paren/bracket close and previous PipeChar matches this
                  If ((Tk[HiTk]=')') or (Tk[HiTk] = ']')) and
                     (Length(PipeChar)>0) and (PipeChar[Length(PipeChar)]=Tk[HiTk])
                     then
                        Delete(PipeChar, Length(PipeChar), 1)
               end;
               P:=S-1; Str:=STR_MAYBE // Move P to new startpos and set string search to none
            end else // Not at string-end or token breaker
            
            {$IFDEF CGI}
            // Check if ?> tag encountered - if yes, get out of codemode
            If (L[P]='?') and (P<Len) and (L[P+1]='>') then begin
               codemode -= 1; S:=P+2; P+=1
            end else
            {$ENDIF}
            
            // If not in string literal and 's' or 'u' encountered, we just came across a string literal
            If (Str = STR_MAYBE) and ((L[P]='s') or (L[P]='u')) then begin
               Str:=STR_START; Utf:=(L[P] = 'u') // Mark string-search and set UTF flag
            end else
               Str:=STR_NOPE // Mark string-search as "we are inside token, 's' and 'u' are not string literal initializers"
               
         end else // Str if not STR_NONE
         
         // We have just encountered string prefix and are looking for delimiter
         If (Str = STR_START) then begin
            
            // If P is outside string, then welp, string prefix at end of line!
            If (P > Len) then begin
               Error(N,'String prefix found at end of line.');
               
               // Add emptystring token
               EnsureEmptyPlaces(1);
               If (Not Utf)
                  then SetHighToken('s""')
                  else SetHighToken('u""');
                  
               S:=Len+1; Str:=STR_MAYBE // Mark stringsearch as done
            end else begin
            // Not outside string. Save delimiter byte and mark "inside string literal" flag
               Delim := L[P]; Str := STR_INSIDE
            end
         end else
         
         // We are inside string literal and have either reached end of line or encountered the delimiter
         If (Str = STR_INSIDE) and ((P > Len) or (L[P] = Delim)) then begin
            
            // Add string token
            EnsureEmptyPlaces(1);
            SetHighToken(Copy(L,S,P-S+1));
            
            // Check if still inside linestring. If yes, skip whitespace.
            // If not, emit error and add delimiter to token end.
            If (P <= Len) then
               While (P<Len) and (L[P+1] <= #$20) do P+=1
            else begin
               Error(N,'String token exceeds line.');
               Tk[HiTk]+=Delim
            end;
            
            S := P+1; Str:=STR_MAYBE // Move startpos and set sting search flag
         end;
         P += 1 // Advance current char pos
      end;
      
      (* Line parsing ends here.                                         *
       * Now we need to check if we have actually extracted any tokens.  *
       * If no, do nothing and exit.                                     *)
      
      If (HiTk < 0) then Exit();
      If (HiTk = 0) and (Tk[0][1]='~') then Exit();
      
      (* If yes, seek out '~' and '!' tokens to determine individual expressions. *
       * Call MakeExpr() with proper token ranges to construct expressions.       *)
      
      S:=0; P:=1; // P holds current token, 0 holds starting token
      While (P <= HiTk) do begin
         
         // Token is a !construct - make an expression from things before this token
         If (Tk[P][1]='!') then begin 
            Ex := MakeExpr(S,P-1,N,S); 
            If (Ex<>NIL) then AddExpr(Ex);
            S := P; 
         end else
         // Token is an ~expression terminator
         If (Tk[P][1]='~') then begin
            // If starting token is not a ~terminator, try to make an expression from the intermediate tokens
            If (Tk[S][1]<>'~') then begin 
               Ex:=MakeExpr(S,P-1,N,S);
               If (Ex<>NIL) then AddExpr(Ex)
            end;
            While (P <= HiTk) and (Tk[P][1] = '~') do P += 1; S := P; // Skip ~terminators
            If (P > HiTk) or (Tk[P][1] <> '!') then P -= 1
         end;
         P += 1
      end;
      
      // If any tokens remaining, try to make an expression out of them
      If (S <= HiTk) and (Tk[S][1]<>'~') then begin
         Ex := MakeExpr(S,HiTk,N,S);
         If (Ex<>NIL) then AddExpr(Ex)
      end
   end;

Procedure ParseFile(Var InputFile:System.Text);
   Var Line:AnsiString; Num:LongWord; 
   begin
      Num := 0;
      While (Not Eof(InputFile)) do begin
         Readln(InputFile,Line); Num+=1;
         ProcessLine(Line, Num)
   end end;

Procedure ReadFile(Var InputFile:System.Text);
   
   {$IFDEF CGI}{$DEFINE __ISCGI__:=True}{$ELSE}{$DEFINE __ISCGI__:=False}{$ENDIF}
   
   Var V:PValue; PTV:PValue; 
   begin
      SetLength(Pr,1); Proc:=0; ExLn:=0; mulico:=0; {$IFDEF CGI} codemode:=0; {$ENDIF}
      SetLength(Pr[0].Arg,0); SetLength(Pr[0].Exp,0); Pr[0].Num:=0;
      
      New(cstruStack, Create());
      SetLength(IfArr,0); SetLength(WhiArr,0); SetLength(RepArr,0);
      SetLength(FileIncludes, 0);
      
      New(Cons,Create());
      SpareVars_Prepare();
      
      V:=NilVal(); V^.Lev := 0; Cons^.SetVal('NIL', V);
      
      {$IFDEF CGI} V:=NewVal(VT_STR, GetEnvironmentVariable('REQUEST_METHOD')); V^.Lev:=0; Cons^.SetVal('REQUEST-METHOD', V); {$ENDIF}
      
      V:=NewVal(VT_STR,YukPath); V^.Lev := 0; Cons^.SetVal('FILE-PATH',V);
      V:=NewVal(VT_STR,YukName); V^.Lev := 0; Cons^.SetVal('FILE-NAME',V);
      
      V:=NewVal(VT_BOO,__ISCGI__);   V^.Lev := 0; Cons^.SetVal('AWFUL-CGI',V);
      V:=NewVal(VT_STR,ParamStr(0)); V^.Lev := 0; Cons^.SetVal('AWFUL-PATH',V);
      V:=NewVal(VT_STR,BuildNum());  V^.Lev := 0; Cons^.SetVal('AWFUL-BUILD',V);
      V:=NewVal(VT_STR,VERSION);     V^.Lev := 0; Cons^.SetVal('AWFUL-VERSION',V);
      V:=NewVal(VT_INT,VREVISION);   V^.Lev := 0; Cons^.SetVal('AWFUL-REVISION',V);
      PTV:=EmptyVal(VT_INT);       PTV^.Lev := 0; Cons^.SetVal('AWFUL-PARSETIME',PTV);
      
      V:=NewVal(VT_FLO,2.71828182845904523536); V^.Lev := 0; Cons^.SetVal('e',  V);
      V:=NewVal(VT_FLO,3.14159265358979323846); V^.Lev := 0; Cons^.SetVal('pi', V);
      
      SetLength(FCal,1); New(FCal[0].Vars,Create()); FCal[0].NumA := 0; FLev := 0;
      
      SetLength(Tk,2); LeTk := 2;
      ParseFile(InputFile); // loop moved to other file
      SetLength(Tk,0);
      
      If (mulico > 0) then Writeln(StdErr,YukName,': multi-line comment stretches past end of code.');
      
      If (Not cstruStack^.Empty) then cstruFatal(0);
      Dispose(cstruStack, Destroy());
      
      If (Proc <> 0) then Fatal(0,'!fun block stretches past end of code.');
      SetLength(Pr[0].Exp, Pr[0].Num); // truncate array of main function
      
      PQInt(PTV^.Ptr)^ := Ceil(TimeStampToMSecs(DateTimeToTimeStamp(Now()))-GLOB_ms)
   end;

end.
